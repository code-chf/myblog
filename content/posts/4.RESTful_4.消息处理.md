---
title: RESTful:4.消息处理
date: 2020-10-29T09:07:53+08:00
lastmod: 2020-10-29T09:07:53+08:00
author: codechf
authorlink: https://github.com/code-chf
cover: https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/xJofAf-NCZJ6s.png
categories:
  - 上课笔记：Web与RESTful技术
tags:
  - java
draft: false
---



Providers消息处理

<!--more-->

<h1 style="text-align:center;">Providers消息处理</h1>

## 做好一个生物学家

- ### 先做好一个生物学家

![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/RBm3CN-2C96E9E65A69B3A8C41CFD619035B8FF.png)

- ### 了解下抽象派画风

![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/54oetW-74F028ADDCE013F94FAD393C1A99AD16.png)



![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/TRZSkd-42417CBDF15F97B779FCEB1E53F2EBC4.png)



- ### 了解程序员画风

![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/TspFbS-B79750B29B218CB4BF9ECB35FCE29715.png)



## 危险地进食与糟糕的产出

![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/QicdVl-42477D1B5CC9F85566D334B0BCF67AC0.png)



## 进食与产出的守卫者

![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/Lnhh00-1CD35729A073F5C2B050E7C62CF5DF83.png)



<h1 style="text-align:center;">如何读取消息提？</h1>

## 问题驱动需求

![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/v5sjl2-21EF68F07A66D452D9F88A0241434341.png)



## MessageBodyReader接口-isReadable方法

### 1.方法定义

```java
public boolean isReadable(Class<?> clazz, Type type, 

       Annotation[] annotations, MediaType mediaType) 
```

### 2.参数详解

` Class<?> class `：输出结果对象的Class，Class是一个类；

` Type type `：输出结果对象的Type，Type是Class的父接口，属于包java.lang.reflect；

` Annotation[] annotations `：当消息体被转换为方法A的参数B时，参数B前所冠有的注解集合；

` MediaType mediaType `：ContentType的大类；



### 3.返回值

当返回值为真时表示可以进行readFrom处理，否则表示无法识别该消息，并抛出异常。



## MessageBodyReader接口-readFrom方法

### 1.方法定义

```java
public Serializable readFrom(   Class clazz, Type type, 

         Annotation[] annotations, MediaType mediaType, 

MultivaluedMap multivaluedMap,InputStream entityStream ) 
```

### 2.参数详解

` Class<?> class `：输出结果对象的Class，Class是一个类；

` Type type `：输出结果对象的Type，Type是Class的父接口，属于包java.lang.reflect；

` Annotation[] annotations `：当消息体被转换为方法A的参数B时，参数B前所冠有的注解集合；

` MediaType mediaType `：ContentType的大类；

` MultivaluedMap multivaluedMap `：HTTP请求报文的头部域集合；

` InputStream entityStream `：HTTP请求报文的请求包体；



### 3.返回值

一个对象。



## MessageBodyReader案例

### 1.案例说明

书商们通过各种方式收集书记信息，并整理成一定的格式。下面是信息系统A交付给书商的信息格式，但书商能够存储的格式是JSON。糟糕的是唯一一个能够为书商写存储方法的小赵正在台湾度蜜月，无法改写该存储方法的实现代码，因此一种更加富有弹性的同样可以实现该目标的代码编写要求被提了出来，现在这个任务落在了你的身上。</br>

信息系统A交付的信息格式：

> isbn=5214589 
> caption=大学语文 
> price=10.25 



书商可以处理的信息格式：

```json
{  
    "caption":"大学语文",  
    "price":10.25,  
    "isbn":"5214589"  
} 
```

### 2.代码示例

- ### Book bean的定义

```java
package restful.bean;  
import java.io.Serializable;  

@SuppressWarnings("serial")  
public class Book implements Serializable{  

    private String caption;  
    private float price;  
    private String isbn;  
    public String getCaption() {  
        return caption;  
    }  

    public void setCaption(String caption) {  
        this.caption = caption;  
    }  

    public float getPrice() {  
        return price;  
    }  

    public void setPrice(float price) {  
        this.price = price;  
    }  

    public String getIsbn() {  
        return isbn;  
    }  

    public void setIsbn(String isbn) {  
        this.isbn = isbn;  
    }  

}  
```



- ### BookAPI的代码

```java
@Path("/book")  
public class BookAPI {     

    @POST  
    @Consumes("book/plain")  
    @Produces("application/json")  
    @Path("/saveBook")    
    public Book saveBook(Book book) {  
        return book;  
    }  

} 
```



- ### Provider的代码

```java
@Provider  
@Consumes("book/plain")  
public class FormatBookInPlain implements MessageBodyReader<Serializable> {  

    @Override  
    public boolean isReadable(Class<?> clazz, Type type,   
                              Annotation[] annotations,   
                              MediaType mediaType) {  

        System.out.println("--------------- isReadable begins ------------------");  
        System.out.printf("class:%s\n", clazz.getName());   
        System.out.printf("type:%s\n", type.getTypeName());  
        System.out.printf("number of annotation:%d\n",annotations.length);  

        for(Annotation annotation : annotations) {  
            System.out.printf("\t annotation:%s\n", annotation.annotationType().getName());  
        }  

        System.out.printf("mediaType:%s\n",mediaType.getType());  
        System.out.println("--------------- isReadable ends ------------------");  

        return true;  
        
    }  

    @Override  
    public Serializable readFrom(Class clazz, Type type,   
                                 Annotation[] annotations,   
                                 MediaType mediaType,   
                                 MultivaluedMap multivaluedMap,  
                                 InputStream entityStream) throws IOException,   
                                 WebApplicationException {  
                                     
        System.out.println("--------------- readFrom begins ------------------");  
        System.out.printf("class:%s\n", clazz.getName());   
        System.out.printf("type:%s\n", type.getTypeName());  
        System.out.printf("number of annotation:%d\n",annotations.length);  

        for(Annotation annotation : annotations) {  
            System.out.printf("\t annotation:%s\n", annotation.annotationType().getName());  
        }  

        System.out.printf("mediaType:%s\n",mediaType.getType());  
        System.out.printf("number of head fields:%d\n",multivaluedMap.keySet().size());  
        Iterator<?> keys = multivaluedMap.keySet().iterator();  
                                     
        while(keys.hasNext()) {  
            String key = (String) keys.next();  
            System.out.printf("\t %s=%s\n",key,multivaluedMap.get(key).toString() );  
        }  

        String entityText = IOUtils.toString(entityStream,"UTF-8");  
        System.out.printf("entity body String:%s\n",entityText);  
        HashMap<String, String> hashMap = new HashMap<String, String>();  
        String[] requestData = entityText.split("\n");  
        for(int index=0;index<requestData.length;index++) {  
            String valuePair = requestData[index];  
            String[] keyValue = valuePair.split("=");  
            hashMap.put(keyValue[0], keyValue[1]);  
            System.out.printf("valuePair:\t%s=%s\n",keyValue[0],keyValue[1]);  
        }  

        Book result = new Book();  
        result.setCaption(hashMap.get("caption").toString());  
        result.setIsbn(hashMap.get("isbn").toString());  
        result.setPrice(Float.valueOf(hashMap.get("price").toString()));  
        System.out.println("--------------- readFrom ends ------------------");  
        return result;  
    }  

}  
```



- ### 效果

![img](https://gitee.com/codechf/uPic-file/raw/master/uPic/2020/10/pfhCye-39547A8279DB648F41E7EA2F02B238A1.png)